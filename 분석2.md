# 백엔드 익명 사용자 지원 수정 명세서

## 문제 요약

현재 백엔드에서 익명 사용자(`mbrId: 0`)로 질문을 작성할 때 500 Internal Server Error가 발생합니다.

## 문제 원인 분석

### 1. QuestionService.create() 메서드의 문제점

**파일**: `src/question/question.service.ts`

```typescript
// 현재 코드 (34-41번째 줄)
const questionWithUser = await this.questionRepository.findOne({
  where: { id: savedQuestion.id },
  relations: ['user'],  // ❌ 문제: mbrId=0일 때 user가 존재하지 않음
});

return plainToClass(QuestionResponseDto, questionWithUser, {
  excludeExtraneousValues: true,
});
```

**문제점:**
- `mbrId: 0` (익명 사용자)인 경우에도 무조건 `relations: ['user']`를 시도
- 데이터베이스에 `mbrId: 0`에 해당하는 실제 사용자가 존재하지 않음
- TypeORM 관계 로딩 실패로 인한 500 에러 발생

### 2. QuestionResponseDto의 문제점

**파일**: `src/question/dto/question-response.dto.ts`

```typescript
export class QuestionResponseDto {
  @Expose()
  @Type(() => UserInfo)
  user: UserInfo;  // ❌ 문제: 익명 사용자의 경우 null일 수 있음
}
```

**문제점:**
- `user` 필드가 필수로 정의되어 있어 익명 사용자 처리 불가
- 익명 사용자의 경우 적절한 기본값 또는 null 처리 필요



### 3. QuestionService.findAll() 메서드의 유사한 문제

**파일**: `src/question/question.service.ts` (44-48번째 줄)

```typescript
const questions = await this.questionRepository.find({
  relations: ['user'],  // ❌ 동일한 문제
  order: { createdAt: 'DESC' },
});
```

## 수정 방안

### 방안 1: 조건부 관계 로딩 (권장)

#### 1.1 QuestionService.create() 수정

```typescript
async create(createQuestionDto: CreateQuestionDto, mbrId: number): Promise<QuestionResponseDto> {
  if (mbrId > 0) {
    const user = await this.userRepository.findOne({ where: { mbrId } });
    if (!user) {
      throw new NotFoundException('User not found');
    }
  }

  const question = this.questionRepository.create({
    ...createQuestionDto,
    mbrId: mbrId,
  });

  const savedQuestion = await this.questionRepository.save(question);
  
  // 수정: mbrId에 따라 조건부 관계 로딩
  const findOptions: any = {
    where: { id: savedQuestion.id },
  };
  
  if (mbrId > 0) {
    findOptions.relations = ['user'];
  }
  
  const questionWithUser = await this.questionRepository.findOne(findOptions);

  // 익명 사용자 처리
  if (mbrId === 0) {
    questionWithUser.user = {
      name: 'Anonymous',
      userId: 'anonymous',
    };
  }

  return plainToClass(QuestionResponseDto, questionWithUser, {
    excludeExtraneousValues: true,
  });
}
```

#### 1.2 QuestionService.findAll() 수정

```typescript
async findAll(): Promise<QuestionResponseDto[]> {
  const questions = await this.questionRepository.find({
    order: { createdAt: 'DESC' },
  });

  // 각 질문에 대해 개별적으로 사용자 정보 처리
  const questionsWithUsers = await Promise.all(
    questions.map(async (question) => {
      if (question.mbrId > 0) {
        const questionWithUser = await this.questionRepository.findOne({
          where: { id: question.id },
          relations: ['user'],
        });
        return questionWithUser;
      } else {
        // 익명 사용자 처리
        question.user = {
          name: 'Anonymous',
          userId: 'anonymous',
        } as any;
        return question;
      }
    })
  );

  return questionsWithUsers.map(question =>
    plainToClass(QuestionResponseDto, question, {
      excludeExtraneousValues: true,
    })
  );
}
```

#### 1.3 QuestionService.findOne() 수정

```typescript
async findOne(id: number): Promise<any> {
  const question = await this.questionRepository.findOne({
    where: { id },
  });

  if (!question) {
    throw new NotFoundException('Question not found');
  }

  // 조건부 사용자 정보 로딩
  if (question.mbrId > 0) {
    const questionWithUser = await this.questionRepository.findOne({
      where: { id },
      relations: ['user'],
    });
    return questionWithUser;
  } else {
    // 익명 사용자 처리
    question.user = {
      name: 'Anonymous',
      userId: 'anonymous',
    } as any;
    return question;
  }
}
```

#### 1.4 QuestionResponseDto 수정

```typescript
class UserInfo {
  @Expose()
  name: string;

  @Expose()
  userId: string;
}

export class QuestionResponseDto {
  @Expose()
  id: number;

  @Expose()
  title: string;

  @Expose()
  description: string;

  @Expose()
  votes: number;

  @Expose()
  answers: number;

  @Expose()
  views: number;

  @Expose()
  tags: string[];

  @Expose()
  @Type(() => UserInfo)
  user: UserInfo; // 익명 사용자의 경우 기본값으로 처리

  @Expose()
  createdAt: Date;

  @Expose()
  updatedAt: Date;

  constructor(partial: Partial<QuestionResponseDto>) {
    Object.assign(this, partial);
  }
}
```

### 방안 2: 익명 사용자 더미 레코드 생성 (대안)

데이터베이스에 `mbrId: 0`인 더미 사용자 레코드를 생성하는 방법:

```sql
INSERT INTO users (mbrId, userId, password, name, email, phone, role, image, reputation) 
VALUES (0, 'anonymous', '', 'Anonymous', 'anonymous@example.com', '', 'USER', '', 0);
```

**장점**: 코드 변경 최소화
**단점**: 데이터베이스에 더미 데이터 추가 필요

### 방안 3: Left Join 사용

Entity에서 관계를 nullable로 설정하고 Left Join 사용:

```typescript
@ManyToOne(() => User, { nullable: true })
@JoinColumn({ name: 'mbr_id' })
user: User | null;
```

## 권장 해결책

**방안 1 (조건부 관계 로딩)**을 권장합니다.

### 이유:
1. **안전성**: 실제 사용자가 없을 때의 에러 방지
2. **유연성**: 익명 사용자와 로그인 사용자 모두 지원
3. **성능**: 불필요한 관계 로딩 방지
4. **확장성**: 향후 익명 사용자 기능 확장 용이

### 적용 순서:
1. QuestionService.create() 메서드 수정
2. QuestionService.findAll() 메서드 수정  
3. QuestionService.findOne() 메서드 수정
4. 테스트 및 검증

## 테스트 케이스

### 1. 익명 사용자 질문 작성
```json
POST /questions
{
  "title": "익명 질문 테스트",
  "description": "익명 사용자가 작성한 질문입니다.",
  "tags": ["test", "anonymous"],
  "mbrId": 0
}
```

**기대 결과:**
```json
{
  "id": 1,
  "title": "익명 질문 테스트",
  "description": "익명 사용자가 작성한 질문입니다.",
  "user": {
    "name": "Anonymous",
    "userId": "anonymous"
  },
  "votes": 0,
  "answers": 0,
  "views": 0,
  "tags": ["test", "anonymous"]
}
```

### 2. 로그인 사용자 질문 작성
```json
POST /questions
{
  "title": "로그인 사용자 질문",
  "description": "로그인한 사용자가 작성한 질문입니다.",
  "tags": ["test", "user"],
  "mbrId": 1
}
```

**기대 결과:**
```json
{
  "id": 2,
  "title": "로그인 사용자 질문",
  "description": "로그인한 사용자가 작성한 질문입니다.",
  "user": {
    "name": "실제사용자명",
    "userId": "user123"
  },
  "votes": 0,
  "answers": 0,
  "views": 0,
  "tags": ["test", "user"]
}
```

### 3. 질문 목록 조회
```
GET /questions
```

**기대 결과**: 익명 사용자와 로그인 사용자의 질문이 모두 정상적으로 표시

## 추가 고려사항

1. **캐싱**: 익명 사용자 정보는 캐싱하여 성능 향상
2. **로깅**: 익명 사용자 활동 로깅 방안 검토
3. **보안**: 익명 사용자의 악용 방지 방안 수립
4. **UI**: 프론트엔드에서 익명/로그인 사용자 구분 표시

## 결론

현재 500 에러의 주요 원인은 백엔드에서 익명 사용자(`mbrId: 0`)에 대한 적절한 처리가 없기 때문입니다. 위의 수정사항을 적용하면 익명 사용자도 정상적으로 질문을 작성할 수 있게 됩니다.

답변 : 그냥 로그인 된 사용자만 글 작성 할 수 있도록 수정하겠다. 하지만 로그인 된 사용자도 500 에러가 존재한다. 로그인 성공하면 user_id(로그인한 사용자 아이디)를 fornt(NextJs)로 넘겨주는데 문제는 글 게시시 mbrId를 요구해서 발생하는 문제인거 같다. 따라서 로그인 시 mbrId 도 front로 응답할때 넘겨주고, 글 작성시 mbrId를 front로 부터 파라미터 값으로 받고 싶다.
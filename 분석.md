# 500 에러 원인 분석 보고서

## 개요
프론트엔드에서 NestJS 백엔드로 질문 생성 요청을 보낼 때 발생하는 500 Internal Server Error의 원인을 분석합니다.

## 1. 프론트엔드 코드 분석

### 파일: `C:\Users\K1240365\Desktop\Nextjs_project-main\app\ask-question\page.tsx`

#### 현재 상태
- **실제 API 호출 없음**: 코드에서 실제 API 호출이 구현되어 있지 않습니다.
- **시뮬레이션만 존재**: 24-28번 라인에서 단순히 콘솔 로그와 타이머만 실행됩니다.

```typescript
// 실제 API 호출이 아닌 시뮬레이션
console.log("Submitting question:", { title, body, tags })
await new Promise((resolve) => setTimeout(resolve, 1000))
```

#### 프론트엔드에서 전송해야 할 데이터 구조
```typescript
// QuestionFormData 타입 (types/index.ts)
interface QuestionFormData {
  title: string    // 질문 제목
  body: string     // 질문 본문
  tags: string     // 태그 (공백으로 구분된 문자열)
}
```

## 2. 백엔드 코드 분석

### 파일: `C:\Users\K1240365\Desktop\Nestjs_Back-main\src\question\question.controller.ts`

#### 컨트롤러 설정
```typescript
@Post()
async create(
  @Body(ValidationPipe) createQuestionDto: CreateQuestionDto,
  @Body('mbrId') mbrId?: number,
): Promise<QuestionResponseDto> {
  const userMbrId = mbrId || 0;
  return this.questionService.create(createQuestionDto, userMbrId);
}
```

#### DTO 검증 조건 (`CreateQuestionDto`)
```typescript
export class CreateQuestionDto {
  @IsString()
  @MinLength(10)    // 최소 10자
  @MaxLength(500)   // 최대 500자
  title: string;

  @IsString()
  @MinLength(20)    // 최소 20자
  description: string;

  @IsArray()
  @IsOptional()
  tags?: string[];
}
```

## 3. 데이터 구조 불일치 문제

### 주요 불일치 사항

| 항목 | 프론트엔드 | 백엔드 | 문제점 |
|------|-----------|--------|--------|
| 본문 필드명 | `body` | `description` | **필드명 불일치** |
| 태그 형식 | `string` (공백 구분) | `string[]` (배열) | **데이터 타입 불일치** |
| API 호출 | 미구현 | 구현됨 | **실제 요청 없음** |

### 구체적인 문제점

1. **필드명 불일치**
   - 프론트엔드: `{ title, body, tags }`
   - 백엔드: `{ title, description, tags }`
   - `body` → `description`으로 매핑 필요

2. **태그 데이터 타입 불일치**
   - 프론트엔드: `"javascript react nextjs"` (문자열)
   - 백엔드: `["javascript", "react", "nextjs"]` (문자열 배열)

3. **검증 조건 미충족**
   - description 최소 20자 조건
   - title 최소 10자 조건

## 4. 500 에러 발생 원인

### 주요 원인
1. **ValidationPipe 실패**: 데이터 구조 불일치로 인한 검증 실패
2. **필드명 매핑 오류**: `body` vs `description` 필드명 불일치
3. **타입 변환 오류**: 태그 문자열을 배열로 변환하지 못함

### 구체적인 에러 시나리오
```json
// 프론트엔드에서 전송하는 데이터
{
  "title": "React Hook 사용법",
  "body": "React Hook을 어떻게 사용하나요?",  // ❌ description이 아닌 body
  "tags": "react hooks javascript",            // ❌ 배열이 아닌 문자열
  "mbrId": 0
}

// 백엔드가 기대하는 데이터
{
  "title": "React Hook 사용법",
  "description": "React Hook을 어떻게 사용하나요?", // ✅ description 필드명
  "tags": ["react", "hooks", "javascript"],          // ✅ 문자열 배열
  "mbrId": 0
}
```

## 5. 해결 방안

### 방안 1: 프론트엔드 수정 (권장)
```typescript
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  setIsSubmitting(true)

  const questionData = {
    title,
    description: body,  // body를 description으로 매핑
    tags: tags.split(' ').filter(tag => tag.trim() !== ''), // 문자열을 배열로 변환
    mbrId: 0  // 익명 사용자
  }

  try {
    const response = await fetch('http://localhost:3001/questions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(questionData),
    })

    if (!response.ok) {
      throw new Error('질문 등록에 실패했습니다.')
    }

    const result = await response.json()
    console.log('질문이 성공적으로 등록되었습니다:', result)
    
    // 폼 초기화
    setTitle('')
    setBody('')
    setTags('')
    alert('질문이 성공적으로 등록되었습니다!')
  } catch (error) {
    console.error('Error:', error)
    alert('질문 등록 중 오류가 발생했습니다.')
  } finally {
    setIsSubmitting(false)
  }
}
```

### 방안 2: 백엔드 수정 (대안)
```typescript
// CreateQuestionDto 수정
export class CreateQuestionDto {
  @IsString()
  @MinLength(10)
  @MaxLength(500)
  title: string;

  @IsString()
  @MinLength(20)
  body: string; // description → body로 변경

  @IsOptional()
  @Transform(({ value }) => {
    if (typeof value === 'string') {
      return value.split(' ').filter(tag => tag.trim() !== '');
    }
    return value;
  })
  @IsArray()
  tags?: string[];
}
```

### 방안 3: 데이터 변환 미들웨어 (고급)
```typescript
// 요청 데이터를 자동으로 변환하는 커스텀 데코레이터 구현
@UseInterceptors(QuestionDataTransformInterceptor)
@Post()
async create(
  @Body(ValidationPipe) createQuestionDto: CreateQuestionDto,
  @Body('mbrId') mbrId?: number,
): Promise<QuestionResponseDto>
```

## 6. 결론

500 에러의 주요 원인은 **프론트엔드와 백엔드 간의 데이터 구조 불일치**입니다. 특히:

1. **필드명 불일치**: `body` vs `description`
2. **데이터 타입 불일치**: 태그의 문자열 vs 배열
3. **실제 API 호출 미구현**: 프론트엔드에서 실제 HTTP 요청을 보내지 않음

**권장 해결책**: 프론트엔드에서 데이터 구조를 백엔드에 맞게 변환하여 전송하는 것이 가장 간단하고 효과적입니다.

## 7. 추가 고려사항

### 개발 환경 설정
- **CORS 설정**: 프론트엔드(Next.js)와 백엔드(NestJS) 간 CORS 정책 확인
- **포트 설정**: 프론트엔드 3000, 백엔드 3001 포트 충돌 방지
- **환경 변수**: API 엔드포인트 URL 환경 변수로 관리

### 에러 처리 개선
- **상세 에러 메시지**: 개발 모드에서 ValidationPipe 에러 상세 정보 노출
- **로깅 시스템**: 백엔드에서 요청 데이터와 에러 상세 로깅
- **사용자 친화적 에러**: 프론트엔드에서 사용자에게 명확한 에러 메시지 제공